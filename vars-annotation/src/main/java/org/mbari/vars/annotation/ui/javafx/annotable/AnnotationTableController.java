package org.mbari.vars.annotation.ui.javafx.annotable;

import io.reactivex.rxjava3.core.Observable;
import javafx.collections.FXCollections;
import javafx.collections.transformation.SortedList;
import javafx.scene.control.skin.TableViewSkin;
import javafx.scene.control.skin.VirtualFlow;
import javafx.beans.binding.Bindings;
import javafx.collections.ObservableList;
import javafx.scene.control.*;
import org.mbari.vars.vampiresquid.sdk.r1.models.Media;
import org.mbari.vars.annotation.ui.Data;
import org.mbari.vars.annotation.etc.rxjava.EventBus;
import org.mbari.vars.annotation.ui.events.AnnotationsAddedEvent;
import org.mbari.vars.annotation.ui.events.AnnotationsChangedEvent;
import org.mbari.vars.annotation.ui.events.AnnotationsRemovedEvent;
import org.mbari.vars.annotation.ui.events.AnnotationsSelectedEvent;
import org.mbari.vars.annotation.ui.messages.SeekMsg;
import org.mbari.vars.annotation.ui.javafx.shared.AnnotationTableViewFactory;
import org.mbari.vars.annotation.ui.UIToolBox;
import org.mbari.vars.annosaurus.sdk.r1.models.Annotation;
import org.mbari.vars.annotation.ui.util.JFXUtilities;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;

import java.util.Collection;
import java.util.ResourceBundle;
import java.util.prefs.Preferences;
import java.util.stream.Collectors;

/**
 * @author Brian Schlining
 * @since 2017-05-10T10:04:00
 *
 * TODO all strings need to be put in i18n
 */
public class AnnotationTableController {

    // Issue #128 - Sort handling was changed in JavaFX 8. We need to use a sortable list
    // in the table, but we can't add/remove directly to that. We need a backing list
    // for mutations. That's tableItems.
    private ObservableList<Annotation> tableItems = FXCollections.observableArrayList();
    private TableView<Annotation> tableView;
    private final ResourceBundle i18n;
    private final EventBus eventBus;
    private final Data data;
    private static final Logger log = LoggerFactory.getLogger(AnnotationTableController.class);


    public AnnotationTableController(UIToolBox toolBox) {
        this.i18n = toolBox.getI18nBundle();
        this.eventBus = toolBox.getEventBus();
        this.data = toolBox.getData();

        Observable<Object> observable = eventBus.toObserverable();

        observable.ofType(AnnotationsAddedEvent.class)
                .subscribe(e -> JFXUtilities.runOnFXThread(() -> {
                    var filtered = filterAnnotations(e.get());
                    tableItems.addAll(filtered);
                }));

        observable.ofType(AnnotationsRemovedEvent.class)
                .subscribe(e -> JFXUtilities.runOnFXThread(() ->
                        tableItems.removeAll(e.get())));

        // Listen for external selection events, but ignore ones generated by this controlle
        observable.ofType(AnnotationsSelectedEvent.class)
                .filter(e -> e.getEventSource() != AnnotationTableController.this)
                .subscribe(e -> select(e.get()));

//        observable.ofType(AnnotationsChangedEvent.class)
//                .subscribe(e -> {
//                    JFXUtilities.runOnFXThread(() -> {
//                        Collection<Annotation> annotations = e.get();
//                        ObservableList<Annotation> items = tableItems;
//                        List<Annotation> intersection = ListUtils.intersection(annotations, items);
//                        for (Annotation a : intersection) {
//                            int idx = items.indexOf(a);
////                            items.set(idx, a);  // Use set instead of remove/add?
//                            items.remove(idx); // FIXME Got a -1 in the bulk edito. Maybe getting this twice??
//                            items.add(idx, a);
//                        }
//                        getTableView().refresh();
//                        eventBus.send(new AnnotationsSelectedEvent(intersection));
//                    });
//                });

        observable.ofType(AnnotationsChangedEvent.class)
                .subscribe(e -> {
                    JFXUtilities.runOnFXThread(() -> {
                        var annotations = e.get();
                        annotations.forEach(a -> {
                            var idx = tableItems.indexOf(a);
                            tableItems.remove(idx);
                            tableItems.add(idx, a);
//                            tableItems.set(idx, a);
                        });
                        getTableView().refresh();
                        eventBus.send(new AnnotationsSelectedEvent(AnnotationTableController.this, annotations));
                    });
                });

        toolBox.getData()
                .showJsonAssociationsProperty()
                .addListener((obs, oldv, newv) -> JFXUtilities.runOnFXThread(() -> tableView.refresh()));

        toolBox.getData()
                .showCurrentGroupOnlyProperty()
                .addListener((obs, oldv, newv) -> {
                    var filteredAnnos = filterAnnotations(data.getAnnotations());
                    JFXUtilities.runOnFXThread(() -> tableItems.setAll(filteredAnnos));
                });

        toolBox.getData()
                .groupProperty()
                .addListener((obs, oldv, newv) -> {
                    if (data.showCurrentGroupOnlyProperty().get()) {
                        var filteredAnnos = filterAnnotations(data.getAnnotations());
                        JFXUtilities.runOnFXThread(() -> tableItems.setAll(filteredAnnos));
                    }
                });

        // Load the column visibility and width
        Preferences prefs = Preferences.userNodeForPackage(getClass());
        Preferences columnPrefs = prefs.node("table-columns");
        getTableView().getColumns()
                .forEach(tc -> {
                    Preferences p = columnPrefs.node(tc.getId());
                    String s = p.get("visible", "true");
                    boolean isVisible = s.equals("true");
                    String w = p.get("width", "100");
                    double width = Double.parseDouble(w);
                    JFXUtilities.runOnFXThread(() -> {
                        tc.setVisible(isVisible);
                        tc.setPrefWidth(width);
                    });
                });


        // Save column visibility and width
        Runtime.getRuntime()
                .addShutdownHook(new Thread(() -> {
                    getTableView().getColumns()
                            .forEach(tc -> {
                                Preferences p = columnPrefs.node(tc.getId());
                                p.put("visible", "false");
                                p.put("width", tc.getWidth() + "");
                            });
                    getTableView().getVisibleLeafColumns()
                            .forEach(tc -> {
                                Preferences p = columnPrefs.node(tc.getId());
                                p.put("visible", "true");
                            });
                }));

    }

    private Collection<Annotation> filterAnnotations(Collection<Annotation> annotations) {
        var currentGroupOnly = data.isShowCurrentGroupOnly();
        if (currentGroupOnly) {
            var currentGroup = data.getGroup();
            if (currentGroup != null) {
                return annotations.stream()
                        .filter(a -> a.getGroup() != null && a.getGroup().equalsIgnoreCase(currentGroup))
                        .collect(Collectors.toList());
            }
        }
        return annotations;
    }

    private void select(Collection<Annotation> annotations) {
        JFXUtilities.runOnFXThread(() -> {
            TableView.TableViewSelectionModel<Annotation> selectionModel = getTableView().getSelectionModel();
            selectionModel.clearSelection();
            if (!annotations.isEmpty()) {
                annotations.forEach(selectionModel::select);
                annotations.stream()
                        .findFirst()
                        .ifPresent(this::scrollTo);
            }
        });
    }

    private void scrollTo(Annotation anno) {
//        if (!isVisible(anno)) {
            tableView.scrollTo(anno);
//            tableView.refresh();
//        }
    }

    private boolean isVisible(Annotation anno) {
        int i = tableView.getItems().indexOf(anno);
        if (i >= 0) {
            int[] visibleRows = getVisibleRows();
//            log.atWarn().log(() -> "i = %d, visible is %d - %d".formatted(i, visibleRows[0], visibleRows[1]));
            return i >= visibleRows[0] && i <= visibleRows[1];
        }
        return false;
    }


    public TableView<Annotation> getTableView() {
        if (tableView == null) {
            tableView = AnnotationTableViewFactory.newTableView(i18n);
            // Issue #128 - Following recommendation in JavaDocs. To handle sorting
            var sortedList = new SortedList<>(tableItems);
            tableView.setItems(sortedList);
            sortedList.comparatorProperty().bind(tableView.comparatorProperty());

            // When less than one, cells are individually sized adn positioned. This is a big
            // performance hit. Issue #128
            tableView.fixedCellSizeProperty().set(-1D); // # Disabled to address Issue #146

            TableView.TableViewSelectionModel<Annotation> selectionModel = tableView.getSelectionModel();
            selectionModel.setSelectionMode(SelectionMode.MULTIPLE);
            selectionModel.selectedItemProperty()
                    .addListener((obs, oldv, newv) -> {
                        eventBus.send(new AnnotationsSelectedEvent(AnnotationTableController.this,
                                selectionModel.getSelectedItems()));
                    });

            tableView.setRowFactory(param -> {
                TableRow<Annotation> row = new TableRow<>();
                ContextMenu menu = new ContextMenu();
                MenuItem seekItem = new MenuItem(i18n.getString("annotable.ctxmenu.seek"));
                seekItem.setOnAction(evt -> {
                    Media media = data.getMedia();
                    Annotation a = row.getItem();
                    SeekMsg.seek(media, a, eventBus);
                });
                menu.getItems().add(seekItem);

                // Set context menu on row, but use a binding to make it only show for non-empty rows:
                row.contextMenuProperty()
                        .bind(Bindings.when(row.emptyProperty())
                            .then((ContextMenu) null)
                            .otherwise(menu));
                return row;
            });




        }
        return tableView;
    }


    /**
     * THis is a total hack. We need it as scrollTo jumps the selected row to the top
     * of the table. Jarring if the row is already visible. As a workaround, we only
     * scroll if the row isn't already visible
     * @return A 2 element ray with the start and end index of visible rows
     */
    private int[] getVisibleRows() {
//        // See https://stackoverflow.com/questions/46474385/how-to-find-the-indices-of-the-visible-rows-in-a-tableview-in-javafx-9/46474693#46474693
        TableViewSkin<?> skin = (TableViewSkin<?>) tableView.getSkin();
        if (skin == null) return new int[] {0, 0};
        VirtualFlow<?> flow = (VirtualFlow<?>) skin.getChildren().get(1);
        int idxFirst;
        int idxLast;
        if (flow != null &&
                flow.getFirstVisibleCell() != null &&
                flow.getLastVisibleCell() != null) {
            idxFirst = flow.getFirstVisibleCell().getIndex();
            if (idxFirst > tableView.getItems().size()) {
                idxFirst = tableView.getItems().size() - 1;
            }
            idxLast = flow.getLastVisibleCell().getIndex();
            if (idxLast > tableView.getItems().size()) {
                idxLast = tableView.getItems().size() - 1;
            }
        }
        else {
            idxFirst = 0;
            idxLast = 0;
        }
        return new int[]{idxFirst, idxLast};

        // This TableViewExt appears to be buggy
//        return tableViewExt.getVisibleRows();
    }

}
